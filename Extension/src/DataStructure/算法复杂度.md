
# 算法复杂度

算法复杂度主要可从 时间 、空间 两个角度评价：

* 时间： 假设各操作的运行时间为固定常数，统计算法运行的「计算操作的数量」 ，以代表算法运行所需时间；
* 空间： 统计在最差情况下，算法运行所需使用的「最大空间」；

## 时间复杂度
根据定义，时间复杂度指输入数据大小为 N时，算法运行所需花费的时间。 需要注意

- 统计的是算法的[计算操作数量]，而不是[运行的绝对时间]。计算操作数量和运行绝对时间呈正相关关系，并不相等。算法运行时间受到[编程语言、计算机处理器速度、运行环境]等多种因素影响。例如，同样的算法使用 Python 或C++ 实现、使用 CPU 或GPU、使用本地DE 或力扣平台提交，运行时间都不同。

- 体现的是计算操作随数据大小 N 变化时的变化情况。假设算法运行总共需要1次操作]、100次操作上，此两情况的时间复杂度都为常数级 0(1);需要 次操作]、100N 次操作的时间复杂度都为O(N)。


- 最佳情况 2(1): nums = [7，a，b，c，...]， 即当数组首个数字为7时，无论 nums 有多少元素，线性查找的循环次数都为1次;
- 最差情况 0(N): nums = [ab，c...] 且 nums 中所有数字都不为 7，此时线性查找会遍历整个数组，循环 N 次;
- 平均情况: 需要考虑输入数据的分布情况，计算所有数据情况下的平均时间复杂度，例如本题目，需要考虑数组长度、数组元素的取值范围等;

> 大0是最常使用的时间复杂度评价渐进符号，下文示例与本 LeetBook 题目解析皆使用0

根据从小到大排列，常见的算法时间复杂度主要有：

O(1)<O(logN)<O(N)<O(NlogN)<O(N!)

![img.png](img.png)



#### 常数 O(1)：

运行次数与 N* 大小呈常数关系，即不随输入数据大小 N* 的变化而变化。

```java

int algorithm(int N) {
    int a = 1;
    int b = 2;
    int x = a * b + N;
    return 1;
}

作者：Krahets
链接：https://leetcode.cn/leetbook/read/illustration-of-algorithm/r81qpe/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



# Reference
leetcodeBook
https://leetcode.cn/leetbook/read/illustration-of-algorithm/r84gmi/