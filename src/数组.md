# 一维数组

## 什么是数组？

数组是具有相同数据类型且按一定次序排列的一组变量的集合体。

## 数组的应用场景

代码繁琐：大量变量的定义。

实现需求繁琐。

## 为什么需要数组？

结论：遇到批量数据的存储和操作时，数组比变量更适合


## 数组的访问
![img.png](img.png)

一维数组arr内的索引是从0开始依次递增的整数，如图所示

```java
//访问数组内的元素
int a = arr[0];
System.out.println(a);//12
```





## 增强for循环的问题

```java
int[] arr = new int[] {1, 2, 3, 4};
for (int i : arr){ sout（i） }
```

无法赋值

无法拿到元素的下标

`适用于仅需要进行遍历的数组`


## 数组的初始化

### 动态初始化

```java
// 数据类型[] 数组名 = new 数据类型[长度];
int[] arr = new int[5];
后边的int[]填入长度
```
### 初始值

| 数组元素类型           | 默认初始值         |
| ---------------------- | ------------------ |
| byte，short，int，long | 0                  |
| float，double          | 0.0                |
| char                   | '\u0000'（空字符） |
| boolean                | false              |
| 引用数据类型           | null               |


### 静态初始化

```java
int[] arr = new int[] {1,2,3,4};
or
int[] arr = {1,2,3,4};// 简写
```


## 数组的遍历

```java
//使用for循环
for(int i=0; i<arr.length;i++){
    System.out.println(i);
        }

//使用增强for循环进行遍历
for(int i : arr){
    System.out.println(i);
        }
//其中i为数组arr中的每个元素

//使用.toString()方法
System.out.println(Arrays.toString(arr));
//[1, 2, 3, 4, 5]


```
## 数组地址问题

Java为了便于虚拟机执行Java程序，将虚拟机的内存划分为 方法区、栈、堆、本地方
法栈、寄存器 这5块区域。

同学们需要重点关注的是 方法区、栈、堆。

**方法区**：字节码文件先加载到这里

```java
Random rand = new Random();
Scanner sc = new Scanner(System.in);
```

**栈**：方法运行时所进入的内存区域，由于变量在方法中，所以变量也在这一块
区域中

**堆**：存储new出来的东西，并分配地址。由于数组是new 出来的，所以数组也在
这块区域。

![img_1.png](img_1.png)

执行顺序，如图

```java
//int a是基本数据类型变量，在栈中，a的变量存储的就是10这个数据
int a =10;

//这里的int[] arr是个引用数据类型，存储的是地址值
int[] arr =new int[]{1,2,3,4,5,6,7,8,9,10};

```

### 多个变量指向同一个数组
```java
int[] arr =new int[]{1,2,3,4,5,6,7,8,9,10};
int[] arr1 = arr;
int[] arr2 = new int[]{1,2,3,4,5,6,7,8,9,10};

System.out.println(arr);//地址1
System.out.println(arr1);//地址1
System.out.println(arr2);//地址2
```


## 最值
```java
//数组求最大值思路：
//        1)先找出数组中0索引的元素，假设为最大值，用max表示【擂主】
//        2)遍历后面的每一个元素和max比较，把较大的元素值重新赋值给max(擂主换人)
//        3)最后max就是所有元素的最大值(最后站在台上的擂主)
int max = -9999;
int min = 9999;
for(int i=0;i<arr.length;i++){
    if(arr[i]>max)max=arr[i];//最大值
    else if(arr[i]<min)min=arr[i];//最小值
}
```

## 数组反转
```java
for(int i=0,int j=arr.length-1;i<arr.length/2;i++,j--){
        int temp=arr[i];
        arr[j]=arr[i];
        arr[i]=temp;
    }

//数组元素交换位置的方法
        
// 1. 使用中间值
int temp=arr[i];
arr[j]=arr[i];
arr[i]=temp;

// 2. 使用位运算
arr[i]=arr[i]^arr[j];
arr[j]=arr[i]^arr[j];
arr[i]=arr[i]^arr[j];
//原理
arr[i]=arr[i]^arr[j]
arr[j]=arr[i]^arr[j]^arr[j];
//arr[j]^arr[j]=0
//arr[j]=arr[i]
//下边同理s
```

## 排序

### 选择排序
表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所 以用到它的时候，数据规模越小越好。

在未排序序列中，先找最大（小）的元素，存放在起始位置，然后找第二大(小)的元素，放在第一个排序好的元素后面，直到将所有元素都排序完

```java
//倒序
public static void main(String[] args) {
    int[] arr = new int[]{6, 7, 3, 2, 1};
    for (int i = 0; i < arr.length; i++) {
        int maxIndex = i;
        //第二个循环从j的值从i的下一位开始就行
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[maxIndex] < arr[j]) {//找到每一轮中的元素最大值
                maxIndex = j;
            }
        }
        //交换
        int temp = arr[maxIndex];
        arr[maxIndex] = arr[i];
        arr[i] = temp;
    }
    System.out.println(Arrays.toString(arr));
}

//找最小值
public static void main(String[] args) {
    int[] arr = new int[]{6, 7, 3, 2, 1};
    for (int i = 0; i < arr.length; i++) {
        int minIndex = i;
        //j和上面一样
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) minIndex = j;
        }
        //交换
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
    System.out.println(Arrays.toString(arr));
}



```





### 插入排序

```java
public static void main(String[] args) {
    //插入排序，正序
    int[] arr = new int[]{6, 7, 3, 2, 1};
    for (int i = 0; i < arr.length; i++) {
        for (int j = 0; j < arr.length; j++) {
            int prev = i - 1;
            int current = arr[i];
            while (prev >= 0 && current < arr[prev]) {
                arr[prev + 1] = arr[prev];
                prev--;
            }
            arr[prev + 1] = current;
        }
    }
    System.out.println(Arrays.toString(arr));
}
```

```java
public static void main(String[] args) {
    //插入排序倒序
    int[] arr = new int[]{6, 7, 3, 2, 1};
    for (int i = 0; i < arr.length; i++) {
        for (int j = 0; j < arr.length; j++) {
            int prev = i - 1;
            int current = arr[i];
            while (prev >= 0 && current > arr[prev]) {
                arr[prev + 1] = arr[prev];
                prev--;
            }
            arr[prev + 1] = current;
        }
    }
    System.out.println(Arrays.toString(arr));
}
```




### 冒泡排序
```java
public static void main(String[] args) {
    //冒泡排序正序
    int[] arr = new int[]{6, 7, 3, 2, 1};
    for (int i = 0; i < arr.length; i++) {
        for (int j = i; j < arr.length; j++) {
            if (arr[j] < arr[i]) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
    System.out.println(Arrays.toString(arr));
}
```

```java
public static void main(String[] args) {
    //冒泡排序倒序
    int[] arr = new int[]{6, 7, 3, 2, 1};
    for (int i = 0; i < arr.length; i++) {
        for (int j = i; j < arr.length; j++) {
            if (arr[j] > arr[i]) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
    System.out.println(Arrays.toString(arr));
}
```



## 查找

### 普通遍历
```java
int[] arr = new int[]{6, 7, 3, 2, 1};
int target = 3;
for (int i = 0; i < arr.length; i++) {
    if ( arr[i]==target){
        System.out.println("第" + (i + 1) + "位");
        break;
    }
}
```

### 二分查找

```java
public static void main(String[] args) {
    int[] arr = new int[]{6, 7, 3, 2, 1};
    int target = 3;
    int left = 0;
    int right = arr.length - 1;

    while (left <= right) {
        int mid = (left + right) >> 1;

        if (target > arr[mid]) {
            left = mid + 1;
        } else if (target < arr[mid]) {
            right = mid - 1;
        } else {
            System.out.println(mid + 1);
            break;
        }
    }
}
```

通过中间值进行比较，中间值比目标大（左边界移动到中间值加一的位置），继续执行直到等于中间值。

```java
    public static void main(String[] args) {
        int[] arr = new int[]{6, 7, 3, 2, 1};
        int target = 5;
        int left = 0;
        int right = arr.length - 1;

        while (left <= right) {
            int mid = (left + right) >> 1;

            if (target > arr[mid]) {
                left = mid + 1;
            } else if (target < arr[mid]) {
                right = mid - 1;
            } else {
                System.out.println(mid + 1);
                break;
            }
        }
        if(left>right){
            System.out.println("数字不在列表中");
        }

    }
```

当数字不在列表中，left会大于right，进行检测就行







# 二维数组



## 二维数组的交换





